---
title: "Micro_report"
format: html
editor: visual
---

## Importing libraries

```{r}
library(tidyverse)
library(broom)  
library(cowplot)

```

## Importing data

```{r}

biopsy <- read_csv("https://wilkelab.org/classes/SDS348/data_sets/biopsy.csv")
```

## Three things we have to do

In general, when performing PCA, weâ€™ll want to do (at least) three things:

## Look at the data in PC coordinates.

```{r}
pca_fit <- biopsy |>  
  select(where(is.numeric)) |>  # retain only numeric columns
  prcomp(scale = TRUE) # do PCA on scaled data
```

Storing the data in pca_fit, we need to consider that we are only taking numeric values (where(is.numeric)) and that we are sorting them in a scale to unit variance, before performing PCA

```{r}
png("abc", type="cairo")
pca_fit |> 
  augment(biopsy) |>  # add original dataset back in
  ggplot(aes(.fittedPC1, .fittedPC2, color = outcome)) + 
  geom_point(size = 1.5) +
  scale_color_manual(
    values = c(malignant = "#D55E00", benign = "#0072B2")
  ) +
  theme_half_open(12) + background_grid()

```

## Look at the rotation matrix.

```{r}
arrow_style <- arrow(
  angle = 20, ends = "first", type = "closed", length = grid::unit(8, "pt")
)

# plot rotation matrix
pca_fit %>%
  tidy(matrix = "rotation") %>%
  pivot_wider(names_from = "PC", names_prefix = "PC", values_from = "value") %>%
  ggplot(aes(PC1, PC2)) +
  geom_point()+
  geom_segment(xend = 0, yend = 0, arrow = arrow_style) +
  geom_text(
    aes(label = column),
    hjust = 1, nudge_x = -0.04
  ) +
  xlim(-1.25, .5) + ylim(-.5, 1) 
```

This plot shows the loadings of the features for PC1 and PC2. The longer the arrow is, the stronger the feature determined the direction of the PC(if the loadings would be squared it would represent the contribution to the variance of this PC). PC2 apperantley represent the changes correlated to mitosis of the breast cancer biopsies. \[Abdi and Willimas, 2010\]

## Look at the variance explained by each PC

To analyze the variance explained by each PC, we use the tidy() function to extract the relevant data:

```{r}
pca_fit |> 
  tidy(matrix = "eigenvalues")
```

In the context of a plot:

```{r}
ggplot(data = (pca_fit |> 
         tidy(matrix = "eigenvalues")),
       mapping = aes(x = PC,
                     y = percent)) +
  geom_col(fill = "skyblue",
           alpha = 0.9) +
  scale_x_continuous(breaks = 1:9) +
  scale_y_continuous(labels = scales::percent_format(),
                     expand = expansion(mult = c(0, 0.1))) +
  theme_minimal()
```

As shown in the plot, the first principal component captures 65% of the variation in the data.
